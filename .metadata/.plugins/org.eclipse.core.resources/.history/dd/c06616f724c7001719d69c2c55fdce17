package ronan_hanley.inside_av.weapons_systems;

import java.util.ArrayList;

import org.newdawn.slick.Graphics;
import org.newdawn.slick.Image;
import org.newdawn.slick.SlickException;

import ronan_hanley.inside_av.Entity;
import ronan_hanley.inside_av.InsideAV;
import ronan_hanley.inside_av.enemy.Enemy;

public abstract class WeaponSystem extends Entity {
	private Image sprite;
	private Image ammo;
	// angle, in radians
	private double angle;
	protected Enemy target = null;
	// ticks since this weapon picked an enemy to target
	protected int ticksSinceTarget = 0;
	
	public WeaponSystem(int x, int y, String spritePath) {
		super(x * InsideAV.TILE_SIZE, y * InsideAV.TILE_SIZE);
		try {
			sprite = new Image(String.format("res/images/weapons/%s", spritePath), false, Image.FILTER_NEAREST);
		} catch (SlickException e) {
			e.printStackTrace();
		}
	}
	
	public void update(ArrayList<Enemy> enemies) {
		if (target == null || ticksSinceTarget >= getMinTargetTime()) {
			// target the closest enemy
			double shortestDistance = Double.MAX_VALUE;
			for (Enemy enemy : enemies) {
				// using the pythagorean theorem to get the distance
				double distance = Math.sqrt(Math.pow(getXExact() - enemy.getXExact(), 2)
										  + Math.pow(getYExact() - enemy.getYExact(), 2));
			}
		}
	}
	
	public void render(Graphics g) {
		sprite.setRotation((float) Math.toDegrees(angle));
		g.drawImage(sprite, getX(), getY());
	}
	
	/**
	 * 
	 * @return How much this weapon costs to buy
	 */
	public abstract double getCost();
	
	/**
	 * The minimum amount of time an enemy can be target for.
	 * 
	 * This is to stop a weapon from rapidly switching between enemies.
	 * @return Minimum time, in game ticks
	 */
	public int getMinTargetTime() {
		// 3 seconds
		return 3 * InsideAV.FPS;
	}
	
}
