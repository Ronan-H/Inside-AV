package ronan_hanley.inside_av.menu_button;

import org.newdawn.slick.Color;
import org.newdawn.slick.Graphics;

/**
 * A set of MenuButtons, for use in a menu.
 * @author Ronan
 */
public class ButtonSet {
	private int startX;
	private int startY;
	private int buttonWidth;
	private int buttonHeight;
	private Color buttonColor;
	private Color buttonHoverColor;
	private int spacing;
	private MenuButton[] buttons;
	
	public ButtonSet(String[] buttonTexts, int startX, int startY, int buttonWidth, int buttonHeight, Color buttonColor, Color buttonHoverColor, int spacing) {
		this.startX = startX;
		this.startY = startY;
		this.buttonWidth = buttonWidth;
		this.buttonHeight = buttonHeight;
		this.buttonColor = buttonColor;
		this.buttonHoverColor = buttonHoverColor;
		this.spacing = spacing;
		
		buttons = new MenuButton[buttonTexts.length];
		for (int i = 0; i < buttonTexts.length; ++i) {
			buttons[i] = new MenuButton(startX, startY, buttonWidth, buttonHeight, buttonColor, buttonHoverColor, buttonTexts[i]);
			startY += buttonHeight + spacing;
		}
	}
	
	public void render(Graphics g) {
		// call each button's render method in turn
		for (MenuButton button : buttons) {
			button.render(g);
		}
	}
	
	/**
	 * Update the buttons based on the cursor position.
	 * 
	 * Eg. if the mouse is hovering over a button, render that button
	 * in the hoverColor instead of color.
	 * 
	 * @return True if the cursor is hovering over a button
	 */
	public boolean updateButtons(int cursorX, int cursorY) {
		// first, reset the buttons
		for (MenuButton button : buttons) button.setHovering(false); 
		
		if (cursorX >= startX && cursorX <= startX + buttonWidth
		 && cursorY >= startY && cursorY <= startY + (buttonHeight * buttons.length) + (spacing * (buttons.length -1))) {
			 /* Cursor is in the rectangle of buttons
			  * (but might be over the spacing)
			  */
			
			// cursor x and y, relative to top left of the rectangle of buttons
			int translatedX = cursorX - startX;
			int translatedY = cursorY - startY;
			
			int buttonNum = translatedY / (buttonHeight + spacing);
			// distance on y axis from the top of the relevant button
			int offsetFromButton = translatedY % (buttonHeight + spacing);
			
			if (offsetFromButton > buttonHeight) {
				// cursor is in the gap between the buttons
				return false;
			}
			
			buttons[buttonNum].setHovering(true);
			return true;
		 }
		
		return false;
	}
	
}
