package ronan_hanley.inside_av.weapons_systems;

import org.newdawn.slick.Image;

import ronan_hanley.inside_av.InsideAV;
import ronan_hanley.inside_av.LevelRoute;

public abstract class BulletWeaponSystem extends WeaponSystem {
	public static final double COST = 100;
	
	public BulletWeaponSystem(int x, int y, Image sprite) {
		super(x, y, sprite);
	}
	
	@Override
	public double getCost() {
		return COST;
	}
	
	@Override
	public void pointTowardsTarget() {
		if (target == null) return;
		
		// -- predict where the target will be --
		
		// Given: ux, uy, vmag (projectile speed), Ax, Ay, Bx, By
		double ux = target.getSpeed() * LevelRoute.OFFSETS[target.getDirection()][0];
		double uy = target.getSpeed() * LevelRoute.OFFSETS[target.getDirection()][1];
		double vmag = getBulletSpeed();
		double Ax = getXExact();
		double Ay = getYExact();
		double Bx = target.getXExact();
		double By = target.getYExact();
		
		// Find the vector AB
		double ABx = Bx - Ax;
		double ABy = By - Ay;

		// Normalize it
		double ABmag = Math.sqrt(ABx * ABx + ABy * ABy);
		double ABx /= ABmag;
		double ABy /= ABmag;

		// Project u onto AB
		uDotAB = ABx * ux + ABy * uy;
		ujx = uDotAB * ABx;
		ujy = uDotAB * ABy;

		// Subtract uj from u to get ui
		uix = ux - ujx;
		uiy = uy - ujy;

		// Set vi to ui (for clarity)
		vix = uix;
		viy = uiy;

		// Calculate the magnitude of vj
		viMag = Math.sqrt(vix * vix + viy * viy);
		vjMag = Math.sqrt(vMag * vMag - viMag * viMag);

		// Get vj by multiplying it's magnitude with the unit vector AB
		vjx = ABx * vjMag;
		vjy = ABy * vjMag;

		// Add vj and vi to get v
		vx = vjx + vix;
		vy = vjy + viy;
		
		setAngle(turretAngle);
	}
	
	@Override
	public void fire() {
		// spawn a bullet
		addProjectile(new Bullet(getX() + (InsideAV.TILE_SIZE / 2) - 2, getY() + (InsideAV.TILE_SIZE / 2) - 2, getAngle(), getBulletSpeed()));
	}
	
	public abstract double getBulletSpeed();
	
}
